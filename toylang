program             : stat_list
stat_list           : (stat)+
stat                : empty_stat
                    | block_stat
                    | var_decl_stat
                    | if_stat
                    | switch_stat
                    | repeat_stat
                    | while_stat
                    | forloop_stat
                    | foreach_stat
                    | break_stat
                    | continue_stat
                    | print_stat
                    | assign_stat
                    | compoundassign_stat

empty_stat          : SEMI
block_stat          : LBRACE stat_list RBRACE
var_decl_stat       : VAR name_list (ASSIGN expr_list)?
if_stat             : IF expr (COLON)? stat (ELIF expr (COLON)? stat)* (ELSE (COLON)? stat)?
switch_stat         : SWITCH expr (COLON)? (CASE expr (COLON)? stat)+ (DEFAULT (COLON)? stat)?
repeat_stat         : REPEAT (COLON)? stat UNTIL expr
while_stat          : WHILE expr (COLON)? stat
forloop_stat        : FOR name IS expr COMMA expr (COMMA expr)? (COLON)? stat
foreach_stat        : FOR name (COMMA name)? IN expr (COLON)? stat
break_stat          : BREAK
continue_stat       : CONTINUE
print_stat          : PRINT expr_list
assign_stat         : lvalue_expr (COMMA lvalue_expr)* ASSIGN expr_list
compoundassign_stat : lvalue_expr compoundassign expr

expr                : select_expr
select_expr         : logic_or_expr (QUERY expr COLON expr)?
logic_or_expr       : logic_and_expr (OR logic_and_expr)*
logic_and_expr      : check_expr (AND check_expr)*
check_expr          : relation_expr ((IN | IS) relation_expr)*
relation_expr       : bit_or_expr ((EQ | NE | LT | LE | GT | GE) bit_or_expr)?
bit_or_expr         : bit_xor_expr (BOR bit_xor_expr)*
bit_xor_expr        : bit_and_expr (BXOR bit_and_expr)*
bit_and_expr        : bit_shift_expr (BAND bit_shift_expr)*
bit_shift_expr      : addition_expr ((BSHL | BSHR) addition_expr)*
addition_expr       : multiple_expr ((ADD | SUB) multiple_expr)*
multiple_expr       : unary_expr ((MUL | DIV | MOD) unary_expr)*
unary_expr          : (unop)* pow_expr
pow_expr            : primary_expr (POW primary_expr)*
primary_expr        : INT_LITERAL | FLOAT_LITERAL | STRING_LITERAL | TRUE | FALSE | NULL | LPAREN expr RPAREN | lvalue_expr

lvalue_expr         : name
name_list           : name (COMMA name)*
expr_list           : expr (COMMA expr)*

name                : IDENTIFIER
compoundassign      : SELF_ADD | SELF_SUB | SELF_MUL | SELF_DIV | SELF_POW | SELF_MOD
                    | SELF_BSHL | SELF_BSHR | SELF_BAND | SELF_BXOR | SELF_BOR
unop                : ADD | SUB | NOT | LEN | BNOT
binop               : ADD | SUB | MUL | DIV | POW | MOD | BSHL | BSHR | BAND | BXOR | BOR
                    | EQ | NE | LT | LE | GT | GE | AND | OR | IN

# sep
LPAREN              (
RPAREN              )
LBRACK              [
RBRACK              ]
LBRACE              {
RBRACE              }
COMMA               ,
DOT                 .
COLON               :
SEMI                ;
QUERY               ?
VARARG              ...

# compare
EQ                  ==
NE                  !=
LT                  <
LE                  <=
GT                  >
GE                  >=

# cal
ADD                 +
SUB                 -
MUL                 *
DIV                 /
POW                 **
MOD                 %
BSHL                <<
BSHR                >>
BAND                &
BXOR                ^
BOR                 |
BNOT                ~
LEN                 #

# assign
ASSIGN              =

# compoundassign
SELF_ADD            +=
SELF_SUB            -=
SELF_MUL            *=
SELF_DIV            /=
SELF_POW            **=
SELF_MOD            %=
SELF_BSHL           <<=
SELF_BSHR           >>=
SELF_BAND           &=
SELF_BXOR           ^=
SELF_BOR            |=

# keyword
AND                 and
NOT                 not
OR                  or

IF                  if
ELIF                elif
ELSE                else

SWITCH              switch
CASE                case
DEFAULT             default

LABEL               label
GOTO                goto
BREAK               break
CONTINUE            continue

REPEAT              repeat
UNTIL               until
WHILE               while
FOR                 for
IS                  is
IN                  in

TRUE                true
FALSE               false
NULL                null

FUNC                func
RETURN              return
LOCAL               local
GLOBAL              global
VAR                 var

PRINT               print
